## 1. 메모리 계층
    레지스터, 캐시, 메모리, 저장장치 
### 1.1 레지스터
    CPU 내부에 있는 작은 메모리
    기억 용량이 제일 적음
    속도가 빠르고 휘발성이 높음
- 예를 들어, 연산 중인 값 or 주소 등을 잠깐 보관
### 1.2 캐시
    CPU 가까이에 있는 중간 저장 공간
    최근에 쓰였거나, 곧 쓰일 데이터를 미리 저장해서 빠르게 불러올 수 있음
- L1, L2, L3가 있음 (캐시 계층에 따른 구분)
    - 용량 L1 < L2 < L3
- 속도는 빠름, 레지스터보다는 느림
- 레지스터는 용량이 너무 작기 때문에 따로 캐시를 두는 것 

#### 1.2.1. 캐시 계층을 두기
    CPU 아키텍처를 설계할 때 성능과 비용을 고려하여 캐시를 단계적으로 나누는 것 
- L1 캐시: 64KB, 매우 빠름 (코어 내부)
- L2 캐시: 512KB, 중간 속도 (코어 내부 or 공유)
- L3 캐시: 8MB, 느리지만 큼 (코어 간 공유)

#### 1.2.2. 캐시 직접 설정하기
    어떤 데이터를 캐시에 둘지, 어떤 캐시 정책을 사용할지 직접 설정하는 것 
- 시간 지역성, 공간 지역성을 고려하여 캐시를 설정한다. 
##### 시간 지역성
    최근에 사용한 데이터에 다시 접근하려는 특성 
##### 공간 지역성
    최근 접근한 데이터를 이루고 있는 공간이나 그 가까운 공간에 접근하려는 특성
### 1.3 주기억장치
    보통 말하는 RAM을 말함
    휘발성, 속도, 기억 용량이 보통
### 1.4 보조기억장치
    SSD/HDD을 일컬음 
    프로그램, 파일 등을 영구 저장
    휘발성, 속도는 낮음 but 기억 용량은 많음

- RAM은 전원을 끄면 날아감, SSD/HDD는 남아있음 


## 2. 캐시히트, 캐시미스 
### 2.1 캐시히트
    캐시에서 원하는 데이터를 찾는 경우
- 캐시히트를 하게 되면 해당 데이터를 제어장치를 거쳐 가져오게 된다. 
- 캐시는 CPU 내부에 존재하기 때문에 CPU 내부 버스를 기반으로 작동하여 빠르다. 
#### 캐시매핑
    캐시가 히트되기 위해 매핑하는 방법 
    직접 매핑, 연관 매핑, 집합 연관 매핑 방법 존재
- 캐시가 작고 메모리는 크기 때문에, 효율적으로 매핑을 해주어야 데이터를 효율적으로 저장하고 가져올 수 있음
##### 직접 매핑
    한 메모리 블록은 오직 한 캐시 라인에만 저장 가능 
    처리가 빠르지만, 충돌 발생 높음 (서로 다른 블록이 같은 캐시 라인에 덮어쓰게 되기 때문)
- 캐시 라인: CPU가 메모리에서 데이터를 가져올 때, 한 번에 읽어오는 고정된 크기의 데이터 블록
- ex) 메모리가 1~100이 있고 캐시가 1~10이 있으면
    - 블록 1, 11, 21, …, 91 → 캐시 라인 1에 매핑
    - 블록 2, 12, 22, …, 92 → 캐시 라인 2에 매핑

##### 연관 매핑
    메모리 블록을 캐시의 어디에든 저장 가능 
    순서를 일치시키지 않는다. 
    모든 블록을 탐색해야 하기 때문에 속도가 느림
- 공간 활용도가 높기 때문에 충돌 가능성 낮음 

##### 집합 연관 매핑
    직접 매핑과 연관 매핑을 합친 것 
    순서는 일치시키지만, 집합을 둬서 저장한다. 
- 블록화되어 있기 때문에 검색에 효율적이다. 

### 2.2 캐시미스 
    캐시를 여러 개의 집합으로 나눈다. 즉, 각 집합에 여러개의 캐시 라인이 존재한다. 
    캐시에서 원하는 데이터가 없어서 주 메모리로 가서 데이터를 찾아오는 것 
- 캐시 미스의 경우 CPU 내부 버스가 아닌 시스템 버스를 기반으로 작동하기 때문에 느리다. 

### 2.3 웹 브라우저의 캐시 
    웹 브라우저의 캐시로 쿠키, 로컬 스토리지, 세션 스토리지 존재 
#### 쿠키
    만료 기한이 있는 키-값 저장소 
    자동으로 서버에 매 요청마다 함께 전송된다.
- 4kb까지 데이터 저장 , 만료기한 설정 가능 
- 주로 로그인 상태 유지, 사용자 식별 등에 사용된다. 

#### 로컬 스토리지
    만료 기한이 없는 키-값 저장소 
    웹 브라우저를 닫아도 유지된다. 
    서버에 자동 전송 x 
- 클라이언트에서만 수정 가능 
- 로그인 유지, 사용자 설정 등 장기 저장에 적합하다. 

#### 세션 스토리지
    만료 기한이 없는 키-값 저장소 
    탭 단위로 세션 스토리지를 생성하기 때문에 탭을 닫으면 해당 데이터 삭제됨 (새 탭에서 열면 다른 저장소로 취급됨)
- 클라이언트에서만 수정 가능 

### 2.4 데이터베이스의 캐싱 계층
    느린 메인 데이터베이스 앞에 임시 저장소(Redis)을 두어 자주 요청되는 데이터를 먼저 반환하게 만드는 구조 
- [ 기존의 방식, RDBMS 기반]
    - [클라이언트] → [DB] → [디스크에서 쿼리 처리] → [응답]
    - RDBMS는 디스크 기반으로, 쿼리 처리 시간이 느림 
        - 자주 조회되는 데이터는 매번 DB에서 읽으면 비효율적임 

- Redis 이용
    - [클라이언트] → [Redis 캐시] → [메인 DB] → [응답]
    	1.	클라이언트가 데이터 요청
        2.	Redis에 해당 키 있는지 확인 (캐시 히트면 → 바로 응답)
        3.	없다면 캐시미스이므로 메인 DB에서 조회후 결과를 Redis에 저장 (다음 요청부터는 캐시 히트가 됨 )
