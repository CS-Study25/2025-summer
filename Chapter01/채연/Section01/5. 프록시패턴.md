# 프록시 패턴 

## 개념 정리
- 실제 객체에 대한 접근을 제어하기 위해 대리가 객체를 두는 패턴이다. 
- 클라이언트는 실제 객체가 아니라 프록시 객체를 통해 간접적으로 접근하게 된다. 
    - 클라이언트는 항상 프록시를 먼저 호출하고, 프록시가 조건을 보고 진짜 객체를 내부에서 생성한다. 

## 목적
- 실제 객체를 감싸고, 그에 대한 접근을 통제하거나 호출을 위임하기 위함
- 굳이 아직 생성하지 않아도 되는 객체는, 생성하는 것을 미루다가 (프록시가 관리하여), 필요한 시점에만 생성함으로써 시스템의 성능과 자원 효율을 높이기 위한 것이다. 


## 언제?(적용 사례)
1. 가상 프록시 (Virtual Proxy)
    - 무거운 객체의 지연 초기화 
2. 보호 프록시 (Protection Proxy)
    - 접근 권한 제어를 위해 중간에 개입하여 판단 
    - 관리자, 사용자에 따라 접근 가능한 API을 제한한다. 
3. 캐시 프록시 (Caching Proxy)
    - 중복 요청 방지, 객체를 한 번 생성하면, 이를 재사용한다. 


## 예시 상황
    큰 이미지 파일을 보여주는 프로그램인데,
    이미지를 처음부터 다 불러오면 느려서,
    실제로 display()가 호출되었을 때만 이미지를 불러오도록 하고 싶은 경우

## 특징
- 진짜 객체에 대한 접근을 제어한다. 

- 실제 객체의 생성을 지연할 수 있다. 
- 진짜 객체와 동일한 인터페이스를 구현한다. 
    - 인터페이스 기반 설계로 느슨한 결합이 가능하다. 
- 기능을 추가하거나 가로챌 수 있다. 
    - 호출 전후에 로깅, 트랜잭션, 캐싱, 동기화 등 삽입 가능하다.
- 클라이언트 코드를 수정하지 않고도 유연하게 확장 가능하다.
    - 실제 객체의 변경 없이 프록시를 끼워넣어 기능을 확장하거나 보호한다. 


## 장점
- 프록시 패턴은 객체의 생성과 접근을 제어하고,부가 기능을 끼워 넣을 수 있어 구조적 유연성과 성능 최적화에 매우 유리하다.

## 구현 방법?
1. 대상이 되는 공통 인터페이스 선언한다.
2. 인터페이스 구현체인 실제 객체 클래스를 만든다. 
    - 이 클래스에서 진짜 기능을 수행함 (ex: 무거운 이미지 display)
3. 인터페이스 구현체인 프록시 클래스를 만든다. 
    - 이 클래스에서 실제 객체를 감싸고, 조건/통제/지연을 처리한다. 
    - (ex: 무거운 객체를 아직 생성하지 않고, 대신 썸네일같은 간단한 객체를 먼저 생성하여 보여주다가, 
    진짜 객체를 보여줘야 하는 시점에서, 생성지연을 통해 무거운 객체를 생성하여 보여주는 경우...)


## 예시 코드 
```java
// 1. 대상 객체 인터페이스 선언
public interface Image {
    void display();
}

// 2. 실제 객체 클래스 구현
public class RealImage implements Image {
    public RealImage(String filename) {
        // load image from disk
    }

    public void display() {
        // show image
    }
}

// 3. 프록시 클래스 구현
public class ProxyImage implements Image {
    private RealImage realImage;
    private String filename;

    public ProxyImage(String filename) {
        this.filename = filename;
    }

    public void display() {
        if (realImage == null) {
            realImage = new RealImage(filename); // 지연 생성
        }
        realImage.display(); // 호출 위임
    }
}

```

## 프록시 서버
> 서버와 클라이언트 사이에서 중계 역할을 하는 서버

### 예시) nginx 프록시 서버
#### nginx을 이용한 프록시 서버 구조
>nginx를 프록시로 두면 서버의 위치를 감추고, 성능을 높이며, 보안을 강화할 수 있는 여러 기능(gzip, 로깅, 캐시 등)을 활용할 수 있다. 
- 사용자: 웹에 접속하는 일반 사용자
- 프록시 서버: 중간에 위치하여 사용자의 요청을 대신 받아서 처리
- 실제 웹 서버: 실제 로직이 실행되고, DB에 연결됨
- 데이터베이스 : 서비스 데이터를 저장

#### 프록시 서버 역할
1. 실제 서버 포트를 숨긴다.  
- 보안 강화 및 네트워크 구조를 은닉할 수 있다. 
- 클라이언트는 프록시 서버만 보게 되며, 실제 웹 서버의 IP, 포트는 숨겨진다.

2. 정적 자원 캐싱
- 프록시가 자주 요청되는 JS, CSS, 이미지 등을 캐싱을 한다. 
- 속도 향상, 서버 부하가 감소된다. 


3. gzip 압축 기능
- 응답 데이터를 gzip으로 압축하여 전송량을 줄인다. 
- 트래픽 절감, 속도 향상 (단, 서버의 CPU 부담은 고려해야 함)

4. 로깅 기능
- 실제 서버 앞단에서 접속 기록이나 요청 로그를 기록 가능
- 보안 분석, 트래픽 모니터링 등에 활용

### 예시) CORS와 프론트엔드의 프록시 서버
#### CORS? 
> Cross - Origin  Resource Sharing 
> : 서버가 웹 브라우저에서 리소스를 로드할 때 다른 오리진을 통해 로드하지 못하게 하는 HTTP 헤더 기반 메커니즘

-  프론트 (예: http://localhost:3000) 
- 백엔드 (예: http://localhost:8080) -> 백엔드 서버가 프론트 서버의 오리진과 다른 상황
- 위와 같은 상황이라면, 같은 localhost여도 포트가 다르면 CORS 에러 발생한다. 
- 이런 상황에서, 프론트 서버가 중계를 요청해야 하며, 이때 프록시 설정이 필요함
> 결국 프록시 서버가 프론트와 백 사이에 서서 같은 오리진처럼 보이게 중계주어 CORS 에러를 해결해주는 것이다. 

> 브라우저 입장에서는 같은 오리진 내에서 모든 요청이 이루어지는 것처럼 보인다. 